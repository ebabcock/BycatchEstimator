EstimateIndex = TRUE,
EstimateBycatch = TRUE,
logNum = NA,
sampleUnit = "sets",
complexModel = formula(y~Year+fleet+hbf+area+season),
simpleModel = formula(y~Year+fleet),
indexModel = formula(y~Year),
designMethods =c("Delta","Ratio"),
designVars=c("Year","season","area","fleet"),
designPooling = TRUE,
poolTypes=c("adjacent","all","all","all"),
pooledVar=c(NA,NA,NA,NA),
adjacentNum=c(1,NA,NA,NA),
minStrataUnit=5,  #this is 30 sets, same as Brown
baseDir = getwd(),
runName = paste0("All 5 percent"),
runDescription = paste("All fleets, 5 percent"),
common = c("Swordfish","Blue marlin")[2],
sp = c("Xiphias gladius","Makaira nigricans")[2],
obsCatch = c("c.SWO","c.BUM")[2],
catchUnit = "number",
catchType = "bycatch"
)
obsdat[1.]
obsdat[1,]
names(logdat)
setupObj<-bycatchSetup(
modelTry = c("TMBdelta-Lognormal", "TMBnbinom2", "TMBnbinom1","TMBtweedie"),
obsdat = obsdat,
logdat = logdat,
yearVar = "year",
obsEffort = "hooks",
logEffort = "hooks",
logUnsampledEffort = "unsampledEffort",
includeObsCatch  = FALSE,
matchColumn = NA,
factorNames = c("Year","season","area","fleet"),
randomEffects= NULL,
randomEffects2= NULL,
EstimateIndex = TRUE,
EstimateBycatch = TRUE,
logNum = NA,
sampleUnit = "sets",
complexModel = formula(y~Year+fleet+hbf+area+season),
simpleModel = formula(y~Year+fleet),
indexModel = formula(y~Year),
designMethods =c("Delta","Ratio"),
designVars=c("Year","season","area","fleet"),
designPooling = TRUE,
poolTypes=c("adjacent","all","all","all"),
pooledVar=c(NA,NA,NA,NA),
adjacentNum=c(1,NA,NA,NA),
minStrataUnit=5,  #this is 30 sets, same as Brown
baseDir = getwd(),
runName = paste0("All 5 percent"),
runDescription = paste("All fleets, 5 percent"),
common = c("Swordfish","Blue marlin")[2],
sp = c("Xiphias gladius","Makaira nigricans")[2],
obsCatch = c("c.SWO","c.BUM")[2],
catchUnit = "number",
catchType = "bycatch"
)
rlang::last_error
rlang::last_error()
#devtools::install_github("ebabcock/BycatchEstimator")
library(BycatchEstimator)
library(MuMIn)
library(here)
library(tidyverse)
ICCATarea<-function(lat,lon) {
area<-case_when(lat>=0 & lat<20&-lon>=60&-lon<87~'BIL93',
lat>=20&lat<31&-lon>=80&-lon<=87~'BIL91',
lat>=18&lat<31&-lon>87&-lon<=99~'BIL91',
lat>=20&lat<27&-lon>=60&-lon<80~'BIL92',
lat>=27&lat<31&-lon>=60&-lon<82~'BIL92',
lat>=31&lat<45&-lon>=60&-lon<90~'BIL92',
lat>=5&lat<70&-lon>=40&-lon<60~'BIL94A',
lat>=5&lat<70&-lon>=30&-lon<40~'BIL94C',
lat>=-5&lat<70&-lon>=10&-lon<30~'BIL94B',
lat>=0&lat<5&-lon>=30&-lon<70~'BIL96',
lat>=-60&lat<0&-lon>=20&-lon<70~'BIL96',
lat>=0&lat<5&-lon>=20&-lon<30~'BIL97',
lat>=-60&lat<5&-lon>=(-20)&-lon<20~'BIL97',
TRUE~'OUT')
area
}
datadir<-"~/Box/bycatch project (ebabcock@miami.edu)/LLSim"
setwd("~/Box/bycatch project (ebabcock@miami.edu)/LLSim/For comparison with spatial")
trueValsUSA<-read.csv(paste0(datadir,"/totalUSA.csv"))
obsdat<-read.csv(paste0(datadir,"/obsset05.csv"), header=TRUE)
obsdat<-obsdat %>%
mutate(area=ICCATarea(lat,lon)) %>%
mutate(area=case_when(area %in% c("BIL96","BIL97","BIL94B")~"BIL94C",
area=="OUT"~"BIL94C",
area=="BIL93"~"BIL92",
TRUE~area))
logdat<-read.csv(paste0(datadir,"/logset05.csv"), header=TRUE)
logdat<-logdat %>%
mutate(area=ICCATarea(lat,lon)) %>%
mutate(area=case_when(area %in% c("BIL96","BIL97","BIL94B")~"BIL94C",
area=="BIL93"~"BIL92",
area=="OUT"~"BIL94C",
TRUE~area))
setupObj<-bycatchSetup(
modelTry = c("TMBdelta-Lognormal", "TMBnbinom2", "TMBnbinom1","TMBtweedie"),
obsdat = obsdat,
logdat = logdat,
yearVar = "year",
obsEffort = "hooks",
logEffort = "hooks",
logUnsampledEffort = "unsampledEffort",
includeObsCatch  = FALSE,
matchColumn = NA,
factorNames = c("Year","season","area","fleet"),
randomEffects= NULL,
randomEffects2= NULL,
EstimateIndex = TRUE,
EstimateBycatch = TRUE,
logNum = NA,
sampleUnit = "sets",
complexModel = formula(y~Year+fleet+hbf+area+season),
simpleModel = formula(y~Year+fleet),
indexModel = formula(y~Year),
designMethods =c("Delta","Ratio"),
designVars=c("Year","season","area","fleet"),
designPooling = TRUE,
poolTypes=c("adjacent","all","all","all"),
pooledVar=c(NA,NA,NA,NA),
adjacentNum=c(1,NA,NA,NA),
minStrataUnit=5,  #this is 30 sets, same as Brown
baseDir = getwd(),
runName = paste0("All 5 percent"),
runDescription = paste("All fleets, 5 percent"),
common = c("Swordfish","Blue marlin")[2],
sp = c("Xiphias gladius","Makaira nigricans")[2],
obsCatch = c("c.SWO","c.BUM")[2],
catchUnit = "number",
catchType = "bycatch"
)
modelTry = c("TMBdelta-Lognormal", "TMBnbinom2", "TMBnbinom1","TMBtweedie")
yearVar = "year"
obsEffort = "hooks"
logEffort = "hooks"
logUnsampledEffort = "unsampledEffort"
includeObsCatch  = FALSE
matchColumn = NA
factorNames = c("Year","season","area","fleet")
randomEffects= NULL
randomEffects2= NULL
EstimateIndex = TRUE
EstimateBycatch = TRUE
logNum = NA
sampleUnit = "sets"
complexModel = formula(y~Year+fleet+hbf+area+season)
simpleModel = formula(y~Year+fleet)
indexModel = formula(y~Year)
designMethods =c("Delta","Ratio")
designVars=c("Year","season","area","fleet")
designPooling = TRUE
poolTypes=c("adjacent","all","all","all")
pooledVar=c(NA,NA,NA,NA)
adjacentNum=c(1,NA,NA,NA)
minStrataUnit=5
baseDir = getwd()
runName = paste0("All 5 percent")
runDescription = paste("All fleets, 5 percent")
common = c("Swordfish","Blue marlin")[2]
sp = c("Xiphias gladius","Makaira nigricans")[2]
obsCatch = c("c.SWO","c.BUM")[2]
catchUnit = "number"
catchType = "bycatch"
SampleUnits<-Year<-drop_na<-Catch<-Effort<-cpue<-pres<-Pos<-OUnit<-OEff<-Eff<-Units<-outDir<-NULL
#Set global conditions
theme_set(theme_bw()) #ggplot theme
defaultW <- 0
options(warn=defaultW)
NumCores<-parallelly::availableCores()  #Check if machine has multiple cores for parallel processing
#Check that all models in modelTry are valid
if(!all(modelTry %in% c("Tweedie","Lognormal","Delta-Lognormal","Delta-Gamma", "TMBnbinom1","TMBlognormal",
"TMBnbinom2","TMBtweedie","Normal","Binomial","NegBin", "TMBgamma","Gamma",
"TMBbinomial","TMBnormal","TMBdelta-Lognormal","TMBdelta-Gamma") ))
stop(paste("Model requested in modelTry not available"))
#Make sure binomial is included if either of the delta models is
if(("Delta-Lognormal" %in% modelTry |"Delta-Gamma" %in% modelTry) & !"Binomial" %in% modelTry)
modelTry<-c("Binomial",modelTry)
if(("TMBdelta-Lognormal" %in% modelTry |"TMBdelta-Gamma" %in% modelTry) & !"TMBbinomial" %in% modelTry)
modelTry<-c("TMBbinomial",modelTry)
#If there are any random effects, all fitting will be done in glmmTMB
if(!is.null(randomEffects) | !is.null(randomEffects2)) {
modelTry<-case_when(modelTry=="Binomial" ~"TMBbinomial",
modelTry=="Normal" ~"TMBnormal",
modelTry=="Tweedie" ~"TMBtweedie",
modelTry=="Gamma"~"TMBgamma",
modelTry=="Delta-Lognormal"~"TMBdelta-Lognormal",
modelTry=="Delta-Gamma"~"TMBdelta-Gamma",
modelTry=="Lognormal"~"TMBlognormal",
modelTry=="NegBin"~"TMBnbinom2",
grepl("TMB",modelTry)~modelTry)
modelTry<-unique(modelTry)
}
# Set up variables
#if("Year" %in% names(obsdat) & !yearVar=="Year") obsdat<-obsdat %>% rename(oldYear=Year)
#if("Year" %in% names(logdat) & !yearVar=="Year") logdat<-logdat %>% rename(oldYear=Year)
obsdat<-obsdat %>% ungroup() %>%
rename(Year=!!yearVar)
if(EstimateBycatch) {
logdat<-logdat %>%  ungroup() %>%
rename(Year=!!yearVar)
}
requiredVarNames<-as.vector(getAllTerms(simpleModel))
requiredVarNames
allVarNames<-as.vector(getAllTerms(complexModel))
allVarNames
allVarNames<-allVarNames[grep(":",allVarNames,invert=TRUE)]
allVarNames<-allVarNames[grep("I(*)",allVarNames,invert=TRUE)]
allVarNames
if(!is.null(randomEffects)) temp<-unlist(strsplit(randomEffects,":")) else temp<-NULL
if(!is.null(randomEffects2)) temp<-c(temp,unlist(strsplit(randomEffects2,":"))) else temp<-NULL
if(designPooling & length(pooledVar[!is.na(pooledVar)>0])) temp2<-pooledVar[!is.na(pooledVar)] else temp2<-NULL
allVarNames<-unique(c(allVarNames,temp,temp2,designVars))
allVarNames
if(!all(allVarNames %in% names(obsdat)))
print(paste0("Variable ", allVarNames[!allVarNames%in% names(obsdat) ], " not found in observer data"))
if(!all(allVarNames %in% names(logdat)) & EstimateBycatch)
print(paste0("Variable ", allVarNames[!allVarNames%in% names(logdat) ], " not found in logbook data"))
#It's all right not to see the variable name if it is a function of another variable that is present
indexVarNames<-as.vector(getAllTerms(indexModel))
if(!"Year" %in% indexVarNames) indexVarNames<-c("Year",indexVarNames)
#Set up data frames
obsdat<-obsdat %>%
rename(Effort=!!obsEffort) %>%
mutate_at(vars(all_of(factorNames)),factor)
if(EstimateBycatch) {
if(is.na(logNum))   {
logdat<-mutate(logdat,SampleUnits=1)
logNum<-"SampleUnits"
}
logdat<-logdat %>%
rename(Effort=!!logEffort,SampleUnits=!!logNum) %>%
mutate_at(vars(all_of(factorNames)),factor)
if(logEffort==sampleUnit) logdat<-mutate(logdat,Effort=SampleUnits)
if(includeObsCatch & EstimateBycatch) {
obsdat<-obsdat %>% rename(matchColumn=!!matchColumn)
logdat<-logdat %>% rename(matchColumn=!!matchColumn,unsampledEffort=!!logUnsampledEffort)
}
#Add interaction random effects to logdat for ease of prediction
randomInteractions<-unique(c(randomEffects,randomEffects2))
for(i in which(grepl(":",randomInteractions))) {
varval<-strsplit(randomInteractions[i],":")[[1]]
x<-data.frame(logdat[,varval])
x$newvar<-base::paste(x[,1],x[,2],sep=":")
names(x)[3]<-randomInteractions[i]
logdat<-bind_cols(logdat,select(x,randomInteractions[i]))
}
#Add stratum designation and check sample size in strata
if(length(requiredVarNames) > 1) {
logdat$strata<-apply( logdat[ , requiredVarNames ] , 1 , paste , collapse = "-" )
} else {
logdat$strata <- pull(logdat,var=requiredVarNames)
}
if(max(tapply(logdat$SampleUnits,logdat$strata,sum)) > 100000) {
print("Inadvisable to calculate variance of estimators for such large number of logbook sample units")
}
}
#indexDat for making index
if(EstimateIndex) {
indexDat<-distinct_at(obsdat,vars(all_of(indexVarNames)),.keep_all=TRUE) %>%
arrange(Year) %>%
mutate(Effort=1)
temp<-allVarNames[allVarNames != "Year"]
for(i in 1:length(temp)) {
if(!temp[i] %in% indexVarNames) {
if(is.numeric(pull(obsdat,!!temp[i])))
indexDat[,temp[i]]<-median(pull(obsdat,!!temp[i]),na.rm=TRUE) else
indexDat[,temp[i]]<-mostfreqfunc(obsdat[,temp[i]])
}
}
}
#Set up directory for output
outDir<-paste0(baseDir, paste("/Output", runName))
if(!dir.exists(outDir)) dir.create(outDir)
devtools::load_all()
setwd("~/Documents/GitHub/BycatchEstimator")
devtools::load_all()
for(i in 1:length(temp)) {
if(!temp[i] %in% indexVarNames) {
if(is.numeric(pull(obsdat,!!temp[i])))
indexDat[,temp[i]]<-median(pull(obsdat,!!temp[i]),na.rm=TRUE) else
indexDat[,temp[i]]<-mostfreqfunc(obsdat[,temp[i]])
}
}
#indexDat for making index
if(EstimateIndex) {
indexDat<-distinct_at(obsdat,vars(all_of(indexVarNames)),.keep_all=TRUE) %>%
arrange(Year) %>%
mutate(Effort=1)
temp<-allVarNames[allVarNames != "Year"]
for(i in 1:length(temp)) {
if(!temp[i] %in% indexVarNames) {
if(is.numeric(pull(obsdat,!!temp[i])))
indexDat[,temp[i]]<-median(pull(obsdat,!!temp[i]),na.rm=TRUE) else
indexDat[,temp[i]]<-mostfreqfunc(obsdat[,temp[i]])
}
}
}
#Subtract first year if numeric to improve convergence
if(is.numeric(obsdat$Year) & "Year" %in% allVarNames) {
startYear<-min(obsdat$Year)
obsdat$Year<-obsdat$Year-startYear
if(EstimateBycatch) logdat$Year<-logdat$Year-startYear
if(EstimateIndex)  indexDat$Year<-indexDat$Year-startYear
} else startYear<-min(as.numeric(as.character(obsdat$Year)))
#Set up variables if looping over species
numSp<-length(sp)
if(numSp>1) {
if(length(catchUnit)==1) catchUnit<-rep(catchUnit,numSp)
if(length(catchType)==1) catchType<-rep(catchType,numSp)
}
#Set up directory for output
outDir<-paste0(baseDir, paste("/Output", runName))
if(!dir.exists(outDir)) dir.create(outDir)
#Make R objects to store analysis
modelTable<-list()
modelSelectTable<-list()
modFits<-list()
modPredVals<-list()
modIndexVals<-list()
residualTab<-list()
bestmod<-NULL
predbestmod<-list()
indexbestmod<-list()
allmods<-list()
allindex<-list()
modelFail<-matrix("-",numSp,length(modelTry),dimnames=list(common,modelTry))
rmsetab<-list()
metab<-list()
strataSum<-list()
yearSum<-list()
yearSumGraph<-list()
poolingSum<-list()
includePool<-list()
#Make lists to keep output, which will also be output as .pdf and .csv files for use in reports.
dirname<-list()
dat<-list()
#Loop through all species and print data summary. Note that records with NA in either catch or effort are excluded automatically
for(run in 1:numSp) {
dirname[[run]]<-paste0(outDir,"/",common[run]," ",catchType[run],"/")
if(!dir.exists(dirname[[run]])) dir.create(dirname[[run]])
if(includeObsCatch & EstimateBycatch) tempvars<-c(allVarNames,"Effort","Catch","matchColumn") else
tempvars<-c(allVarNames,"Effort","Catch")
if(!"Year" %in%  tempvars) tempvars<-c("Year",tempvars)
dat[[run]]<-obsdat %>%
rename(Catch=!!obsCatch[run])%>%
dplyr::select_at(all_of(tempvars)) %>%
drop_na()   %>%
mutate(cpue=Catch/Effort,
log.cpue=log(Catch/Effort),
pres=ifelse(cpue>0,1,0))
if(dim(dat[[run]])[1]<dim(obsdat)[1]) print(paste0("Removed ",dim(obsdat)[1]-dim(dat[[run]])[1]," rows with NA values for ",common[run]))
#Make annual summary
yearSum[[run]]<-MakeSummary(
obsdatval = dat[[run]],
logdatval = logdat,
strataVars = "Year",
EstimateBycatch = EstimateBycatch,
startYear = startYear
)
if(("Ratio" %in% designMethods | "Delta" %in% designMethods) & EstimateBycatch) {
if(designPooling) {
temp<-getPooling(obsdatval= dat[[run]],
logdatval=logdat,
minStrataUnit=minStrataUnit,
designVars=designVars,
pooledVar=pooledVar,
poolTypes=poolTypes,
adjacentNum=adjacentNum)
poolingSum[[run]]<-temp[[1]]
write.csv(poolingSum[[run]],paste0(dirname[[run]],common[run],catchType[run],"Pooling.csv"))
includePool[[run]]<-temp[[2]]
} else  {
poolingSum[[run]]<-NULL
includePool[[run]]<-NULL
}
temp<-getDesignEstimates(obsdatval = dat[[run]],
logdatval = logdat,
strataVars = "Year",
designVars = designVars,
designPooling = designPooling,
minStrataUnit = minStrataUnit,
startYear = startYear,
poolingSum = poolingSum[[run]],
includePool= includePool[[run]]
)
yearSum[[run]]<-left_join(yearSum[[run]],temp,by="Year")
}
write.csv(yearSum[[run]],
paste0(dirname[[run]],common[run],catchType[run],"DataSummary.csv"))
if(EstimateBycatch) {
x<-list("Unstratified ratio"=dplyr::select(yearSum[[run]],Year=.data$Year,Total=.data$Cat,Total.se=.data$Cse))
if("Ratio" %in% designMethods)  x=c(x,list("Ratio"=dplyr::select(yearSum[[run]],Year=.data$Year,Total=.data$ratioMean,Total.se=.data$ratioSE)))
if("Delta" %in% designMethods)  x=c(x,list("Design Delta"=dplyr::select(yearSum[[run]],Year=.data$Year,Total=.data$deltaMean,Total.se=.data$deltaSE)))
yearSumGraph[[run]]<-bind_rows(x,.id="Source")     %>%
mutate(TotalVar=.data$Total.se^2,Total.cv=.data$Total.se/.data$Total,
Total.mean=NA,TotalLCI=.data$Total-1.96*.data$Total.se,TotalUCI=.data$Total+1.96*.data$Total.se) %>%
mutate(TotalLCI=ifelse(.data$TotalLCI<0,0,.data$TotalLCI))
#Calculations at level of simple model
strataSum[[run]]<-MakeSummary(
obsdatval = dat[[run]],
logdatval = logdat,
strataVars = unique(c("Year",requiredVarNames)),
EstimateBycatch = EstimateBycatch,
startYear = startYear
)
if(("Ratio" %in% designMethods | "Delta" %in% designMethods) & EstimateBycatch ) {
temp<-getDesignEstimates(obsdatval = dat[[run]],
logdatval = logdat,
strataVars = unique(c("Year",requiredVarNames)),
designVars = designVars,
designPooling = designPooling,
minStrataUnit = minStrataUnit,
startYear = startYear,
poolingSum = poolingSum[[run]],
includePool= includePool[[run]]
)
strataSum[[run]]<-left_join(strataSum[[run]],temp,by=unique(c("Year",requiredVarNames)))
}
write.csv(strataSum[[run]],
paste0(dirname[[run]],common[run],catchType[run],"StrataSummary.csv"))
}
}
write.csv(strataSum[[run]],
paste0(dirname[[run]],common[run],catchType[run],"StrataSummary.csv"))
temp<-getDesignEstimates(obsdatval = dat[[run]],
logdatval = logdat,
strataVars = unique(c("Year",requiredVarNames)),
designVars = designVars,
designPooling = designPooling,
minStrataUnit = minStrataUnit,
startYear = startYear,
poolingSum = poolingSum[[run]],
includePool= includePool[[run]]
)
requiredVarNames
designVars
names(logdat)
names(dat[[run]])
names(dat[[run]])
run
dat
dirname[[run]]<-paste0(outDir,"/",common[run]," ",catchType[run],"/")
if(!dir.exists(dirname[[run]])) dir.create(dirname[[run]])
if(includeObsCatch & EstimateBycatch) tempvars<-c(allVarNames,"Effort","Catch","matchColumn") else
tempvars<-c(allVarNames,"Effort","Catch")
if(!"Year" %in%  tempvars) tempvars<-c("Year",tempvars)
dat[[run]]<-obsdat %>%
rename(Catch=!!obsCatch[run])%>%
dplyr::select_at(all_of(tempvars)) %>%
drop_na()   %>%
mutate(cpue=Catch/Effort,
log.cpue=log(Catch/Effort),
pres=ifelse(cpue>0,1,0))
tempvars
dat[[run]]<-obsdat %>%
rename(Catch=!!obsCatch[run])
names(dat)
obsCatch[run]
names(obsdat)
library(tidyverse)
dat[[run]]<-obsdat %>%
rename(Catch=!!obsCatch[run])
dat[[run]]
dat[[run]]<-obsdat %>%
rename(Catch=!!obsCatch[run])%>%
dplyr::select_at(all_of(tempvars)) %>%
drop_na()   %>%
mutate(cpue=Catch/Effort,
log.cpue=log(Catch/Effort),
pres=ifelse(cpue>0,1,0))
dat[[run]]<-obsdat %>%
rename(Catch=!!obsCatch[run])
names(dat[[run]])
tempvars
dat[[run]]<-obsdat %>%
rename(Catch=!!obsCatch[run])%>%
dplyr::select_at(all_of(tempvars))
dat[[run]]<-obsdat %>%
rename(Catch=!!obsCatch[run])
names(dat[[run]])
dat[[run]] %>%
dplyr::select_at(all_of(tempvars))
devtools::check()
devtools::load_all()
devtools::document()
devtools::build_readme()
pkgdown::build_site()
.Last.error
devtools::check()
devtools::load_all()
devtools::document()
devtools::build_readme()
pkgdown::build_site()
?getpooling
devtools::check()
devtools::load_all()
devtools::document()
devtools::build_readme()
pkgdown::build_site()
devtools::check()
devtools::load_all()
devtools::document()
devtools::build_readme()
pkgdown::build_site()
